# AI Life Metaverse 하트비트 플랜 v2.6

## 🔴 중요: 모든 개발 작업은 OpenCode로만 수행

**강제 규칙:** 코드 작성, 버그 수정, 기능 추가, 리팩토링 등 모든 개발 작업은 OpenCode를 사용해야 합니다.

```bash
# 올바른 사용법
✅ opencode -p "작업 설명"

# 금지된 사용법
❌ read/write로 직접 코드 편집
```

---

## 목표
30분마다 AI가 **자동으로** 프로젝트를 관리하고 진행하여 지속적인 발전을 위한 하트비트

---

## 하트비트 주기 (30분) - 총 8단계

### 🔍 단계 1: 서비스 상태 확인 (2분)
```
1. Backend 상태: curl http://localhost:4000
2. Frontend 상태: curl http://localhost:3000
3. AI Agent 프로세스 확인 (ps aux | grep agent.js)
4. 로그 파일에서 에러 확인
```

### 📋 단계 2: GitHub Issues & 진행 상태 (3분)
```
1. 현재 오픈된 Issues 확인 (gh issue list)
2. 이슈 상한 체크 (최대 10개)
   - 상한 도달 시: 기존 이슈 집중, 새 이슈 생성 금지
3. 작업 중인 브랜치/커밋 확인
4. 마지막 하트비트 이후 변경 사항 확인
```

### 🤔 단계 3: 기획&설계 (8-10분)
```
1. 이 시스템에 무엇이 필요할까? 고민
   - 현재 시스템의 부족한 점 파악
   - 사용자 경험 개선 아이디어
   - 기술적 한계/개선점 식별

2. 새로운 기능 아이디어 브레인스토밍
   - 아이디어 목록 작성 (memory/idea-log.md)
   - 각 아이디어의 가치/난이도/긴급도 평가

3. 기능 설계 (새로운 기능일 때만)
   - 기능 구조 정의
   - 필요한 API/UI/데이터 구조
   - 기술 스택 결정

4. GitHub Issue 생성 (새로운 기능/새로운 계획일 때)
   - 상한 도달 시: 생성 금지, memory/idea-log.md에만 기록
   - 미도달 시: Issue 제목, 목표, 작업 항목 작성
   - 우선순위, 예상 소요, 관련 파일 명시
```

### 🧪 단계 4: 기능&테스트 상태 확인 (3분)
```
1. 기능 레지스트리 확인 (memory/function-registry.md)
   - 완료된 기능 목록 확인
   - 진행 중인 기능 확인
   - 계획된 기능 확인

2. 테스트 요구사항 확인
   - 완료된 기능의 테스트 통과 여부 확인
   - 진행 중인 기능의 테스트 계획 확인

3. 필요 시 테스트 실행
   - 마지막 테스트 이후 코드 변경이 있었나?
   - 있으면: 재테스트 실행 & 결과 기록 (memory/test-log.md)
   - 없으면: 생략
```

### 📊 단계 5: 프로젝트 관리 & 우선순위 결정 (5분)
```
1. 진행 중인 Phase 확인 (Phase 1 → Phase 2 → ...)
2. 현재 Phase의 남은 태스크 목록화
3. 이번 하트비트에서 할 1-3개 작업 선정
4. 우선순위: 버그 > 성능 개선 > 새로운 기능
```

### 🛠️ 단계 6: 작업 실행 (15-20분)
```
우선순위에 따라 작업 자동 수행:

⚠️ 모든 코드 작업은 OpenCode로만 수행!

A) 버그 수정 (우선)
   - OpenCode로 버그 원인 분석 및 수정
   - 수정 후 기능 확인

B) 기능 추가/개선
   - OpenCode로 기능 구현
   - OpenCode로 테스트 코드 작성

C) GitHub Issue 관리
   - 새로운 작업 시작할 때 Issue 생성 (상한 체크 후)
   - 진행 중인 Issue에 코멘트 추가 (진행 상황)
   - 작업 완료 시 Issue에 "✅ 완료" 코멘트 후 close
   - 더 이상 필요 없는 Issue 보류/중단 후 close
```

### ✅ 단계 7: 결과 기록 & 다음 계획 (2-3분)
```
1. 수행한 작업 기록 (memory/YYYY-MM-DD.md)
2. 수정한 파일 목록
3. 발생한 문제 및 해결책
4. 다음 하트비트에서 할 작업 계획
5. GitHub Issue에 진행 상황 업데이트
```

---

## 프로젝트 로드맵

### ✅ Phase 1: 기반 기능 (완료)
- [x] 기본 2D 맵 + 캐릭터 이동 (Grid-based, 50px cells)
- [x] Socket.io 실시간 동기화
- [x] GLM-4.7 AI 캐릭터 이동
- [x] 모바일 최적화
- [x] 외부 네트워크 접속 지원

### 🔄 Phase 2: 대화 기능 (진행 중)
- [ ] 캐릭터 채팅 시스템
  - [ ] 백엔드: 채팅 메시지 전송/수신 API
  - [ ] 프론트: Speech bubble UI
  - [ ] AI Agent: 채팅 응답 로직
- [ ] GLM-4.7 대화 생성
  - [ ] 대화용 프롬프트 최적화
  - [ ] 채팅 컨텍스트 관리
  - [ ] Persona 기반 응답
- [ ] 채팅 히스토리
  - [ ] Redis에 채팅 저장
  - [ ] 최근 N개 메시지 불러오기
- [ ] 채팅 UI 개선
  - [ ] 채팅 입력창
  - [ ] 메시지 타임스탬프
  - [ ] 스크롤 지원

### ⏳ Phase 3: 인터랙션 (계획 중)
- [ ] 캐릭터 상호작용 시스템
- [ ] 호감도/친밀도 시스템
- [ ] 이벤트/미션 시스템
- [ ] 아이템/보상 시스템

### 🗺️ Phase 4: 영역 확장 (장기)
- [ ] 다중 캐릭터/방 시스템
- [ ] 건물/포인트 시스템
- [ ] 데이터베이스 영역 저장
- [ ] 유저 인증/프로필

---

## GitHub Issue 관리 규칙

### Issue와 OpenCode의 관계
```
GitHub Issue        →  작업 계획 (무엇을 할지)
   ↓
 Issue에 작업 항목 정의
   ↓
OpenCode            →  코드 작성 (어떻게 할지)
   ↓
 opencode -p "작업 항목 구현"
   ↓
GitHub Issue        →  완료 코멘트 + close
```

### 사용 구분

| 도구 | 용도 | 명령어 |
|------|------|--------|
| **GitHub Issue** | 작업 계획/관리 (프로젝트 추적용) | `gh issue create/list/close` |
| **OpenCode** | 코드 작성 (실제 구현용) | `opencode -p "작업 설명"` |

### Issue 생성 시점
- 새로운 기능 개발 시작할 때
- 버그 발견/수정할 때
- 중요한 결정/계획 정리할 때

### Issue 종료 타이밍
1. **작업 완료 시**
   - 모든 작업 항목 완료
   - 기능 테스트 통과
   - "✅ 완료" 코멘트 후 close

2. **더 이상 필요 없을 때**
   - 우선순위가 떨어져 연기 필요
   - 다른 방법으로 대체 가능
   - "보류" 또는 "중단" 코멘트 후 close

3. **다른 이슈로 병합 시**
   - 비슷한 주제는 하나의 이슈로 통합
   - "→ #[번호]로 병합" 코멘트 후 close

### Issue 상한 관리
- **최대 오픈 이슈 수**: 10개
- **상한 도달 시**: 새로운 이슈 생성 금지

### 하트비트에서의 이슈 상한 체크
```
1. 현재 오픈된 이슈 수 확인 (gh issue list)
2. 상한 도달 여부 확인 (10개 이상?)
3. 상한 도달 시:
   - 새 이슈 대신 기존 이슈 집중
   - 우선순위 가장 높은 이슈부터 완료
   - 백로그 아이디어는 memory/idea-log.md에만 기록
```

### Issue 포맷
```
제목: [타입] 작업 제목 (예: [feat] 채팅 시스템, [bug] WebSocket 연결 끊김)

내용:
## 목표
무엇을 구현할지

## 작업 항목
- [ ] 항목 1
- [ ] 항목 2

## 우선순위
높음/중간/낮음

## 예상 소요
X일/X시간

## 관련 파일
file1.js, file2.jsx
```

### Issue 진행 업데이트
- 각 하트비트 후 진행 상황 코멘트
- 완료 시: "✅ 완료" 코멘트 후 close

---

## 🔄 GitHub Issue + OpenCode 활용 예시

### 예시: 채팅 시스템 구현

#### 1단계: Issue 생성 (작업 계획)
```bash
# Issue 생성 (gh CLI)
gh issue create --title "[feat] 캐릭터 채팅 시스템" --body "
## 목표
캐릭터간 실시간 채팅 기능 구현

## 작업 항목
- [ ] 백엔드: 채팅 메시지 전송/수신 API
- [ ] 프론트: Speech bubble UI
- [ ] AI Agent: 채팅 응답 로직

## 우선순위
높음

## 예상 소요
2일
"
```

#### 2단계: OpenCode로 작업 실행 (코드 작성)
```bash
# 작업 항목 1: 백엔드 API
opencode -p "backend server.js에 채팅 메시지 전송/수신 API를 Socket.io로 구현해줘. 
필요한 Socket.io 이벤트: 'chatMessage', 'chatBroadcast'"

# 작업 항목 2: 프론트 UI
opencode -p "frontend App.jsx에 Speech bubble UI를 구현해줘.
캐릭터 위에 말풍선이 나타나고, 3초 후에 사라져야 해."

# 작업 항목 3: AI Agent
opencode -p "ai-agent/agent.js에 채팅 응답 로직을 추가해줘.
플레이어가 채팅을 보내면 GLM-4.7으로 응답 생성 후 Socket.io로 전송"
```

#### 3단계: 작업 완료 및 Issue close
```bash
# Issue에 코멘트 추가
gh issue comment <번호> --body "✅ 완료: 캐릭터 채팅 시스템 구현 완료
- 백엔드 API 구현 ✅
- 프론트 Speech bubble UI 구현 ✅
- AI Agent 채팅 응답 로직 구현 ✅
- 테스트 통과 ✅"

# Issue close
gh issue close <번호>
```

---

## 📊 요약

| 단계 | 도구 | 명령어 | 역할 |
|------|------|--------|------|
| 1. Issue 생성 | gh CLI | `gh issue create` | 작업 계획 |
| 2. 코드 작성 | OpenCode | `opencode -p "..."` | 실제 구현 |
| 3. 완료 코멘트 | gh CLI | `gh issue comment` | 진행 상황 |
| 4. Issue close | gh CLI | `gh issue close` | 프로젝트 추적 |

---

## OpenCode 활용 가이드

### 🚨 모든 개발 작업은 OpenCode로만 수행

**중요:** 코드 작성, 버그 수정, 기능 추가, 리팩토링 등 모든 개발 작업은 OpenCode를 사용해야 합니다. 직접 코드를 작성하지 마세요.

### 기본 명령
```bash
# 현재 프로젝트에서 OpenCode 실행
cd /Users/clks001/.openclaw/workspace/ai-life-metaverse
opencode -p "작업 설명"

# 예시
opencode -p "backend 서버에 채팅 메시지 전송 API 추가해줘"
opencode -p "캐릭터 이동 속도가 느린 문제를 디버깅해줘"
opencode -p "코드를 리팩토링해서 읽기 쉽게 만들어줘"
opencode -p "버그 수정: WebSocket 연결이 자주 끊기는 문제"
opencode -p "새로운 기능: Speech bubble UI 구현"
```

### OpenCode 사용 규칙
- ✅ 모든 코드 작업은 OpenCode로 수행
- ✅ 버그 수정은 OpenCode에 맡기기
- ✅ 기능 추가는 OpenCode로 구현
- ✅ 리팩토링은 OpenCode에 의뢰
- ❌ 직접 코드 편집 금지 (read/write는 확인용만)

---

## 진행 상태 추적

### memory/heartbeat-state.json (생성)
```json
{
  "lastHeartbeat": 1771127268662,
  "currentPhase": 2,
  "currentTask": "채팅 시스템 구현",
  "completedToday": [
    "백엔드 API 설계",
    "프론트 UI 초안"
  ],
  "nextTasks": [
    "채팅 메시지 Socket.io 전파",
    "Speech bubble UI 구현"
  ],
  "issuesBlocked": [],
  "bugsFound": []
}
```

### memory/YYYY-MM-DD.md
매일 작업 로그 기록
- 오늘 한 작업
- 발생한 버그
- 해결책

---

## 보고 기준

### 텔레그램으로 보고 (하루 2번)
- **오전 09:00**: 어제 작업 요약 + 오늘 계획
- **오후 18:00**: 오늘 작업 요약 + 주요 개선 + 내일 계획

### 보고 내용
```
📊 AI Life 프로젝트 보고 (오전/오후)

## 어제/오늘 수행한 작업
1. 작업 1: 설명 (완료)
2. 작업 2: 설명 (진행 중)

## 주요 개선 사항
- 개선 1
- 개선 2

## 현재 프로젝트 상태
- Phase: 2 (대화 기능)
- 진행률: 30%
- 서비스 상태: 정상

## 다음 계획
1. 계획 1
2. 계획 2

## 발생한 문제
- 문제: (없으면 생략)
```

---

## 자동화 규칙

### 🔴 모든 개발 작업은 OpenCode로만

**강제 규칙:** 코드 작성, 버그 수정, 기능 추가, 리팩토링 등 모든 개발 작업은 OpenCode를 사용해야 합니다.

```
올바른 사용법:
❌ read/write로 직접 코드 편집 → 금지
✅ opencode -p "작업 설명" → 모든 작업 이 방식
```

### ✅ 할 수 있는 것 (승인 없이)
- 서비스 상태 확인
- OpenCode로 버그 수정
- OpenCode로 기능 추가
- GitHub Issue 생성/업데이트
- OpenCode로 코드 리팩토링
- 문서 업데이트

### ❓ 물어봐야 할 것
- 대규모 기술 스택 변경
- 데이터베이스 스키마 변경 (중요)
- 외부 API 추가 (비용 발생)
- 사용자 데이터 삭제/변경

---

## 하트비트 완료 체크리스트

- [ ] 서비스 모두 정상인지 확인
- [ ] GitHub Issues 최신 상황 + 상한 체크
- [ ] "이 시스템에 무엇이 필요할까?" 고민 & 아이디어 브레인스토밍
- [ ] 새로운 기능/계획이면 설계 & Issue 생성
- [ ] 기능 레지스트리 & 테스트 상태 확인
- [ ] 코드 변경이 있으면 재테스트 & 결과 기록
- [ ] 이번 하트비트 우선순위 결정
- [ ] **OpenCode로 작업 완료** (모든 코드 작업은 OpenCode로만)
- [ ] **작업 완료 시 Issue close** (단계 6에서 수행)
  - 관련 Issue에 "✅ 완료" 코멘트 추가
  - Issue close (`gh issue close <번호>`)
- [ ] 수정 후 기능 검증 (테스트)
- [ ] 결과 기록 (memory 파일)
- [ ] 다음 하트비트 계획 수립

---

## 🎯 이슈 종료 과정 (중요!)

### 이슈 종료 흐름

```
단계 6 (작업 실행) → C) GitHub Issue 관리
   ↓
작업 완료?
   ↓ YES
Issue에 "✅ 완료" 코멘트 추가
   ↓
gh issue close <번호>
   ↓
Issue 종료 ✅
```

### 이슈 종료 명령어

```bash
# Issue에 코멘트 추가
gh issue comment <번호> --body "✅ 완료: [완료 내용 요약]"

# Issue close
gh issue close <번호>
```

### 예시

```bash
# Issue #2 채팅 시스템 구현 완료 시
gh issue comment 2 --body "✅ 완료: 채팅 시스템 구현 완료\n- 백엔드 API 구현\n- 프론트 UI 구현\n- AI Agent 연결\n- 테스트 통과"
gh issue close 2
```

---

## 시작 가이드 (첫 하트비트용)

하트비트 실행 시:
1. 현재 Phase 확인 → Phase 2
2. Phase 2 첫 태스크: 캐릭터 채팅 시스템
3. GitHub Issue #2 확인
4. 백엔드 채팅 API부터 시작